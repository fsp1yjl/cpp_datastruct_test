

### 1 两数之和

所有数放入哈希map, 选定一个数后，判断另外一个数是否在哈希表中

### 2 两数相加

因为linklist 是逆序存放，直接逐位相加，考虑下进位情况。

### 3 无重复字符对最长子串

滑动窗口，left,right双指针，滑动窗口向右移动，用一个哈希map存放单个字符出现的最新索引位置， 如果新遍历到的字符已经在map中存在，且位于滑动窗口中，则表示出现重复，进行更新滑动窗口左侧的操作。


### 4 寻找两个正序数组的中位数

寻找两个排序linklist的中位数，且要求时间复杂度o(log(m+n)),  如果没有这个要求，则直接寻找第（m+n+1)/2 和（m+n+2）/2 即可，但是这样时间复杂度是o(m+n).  这里假设中位数为第k个元素，则分别在两个linkList中找第k/2个元素，进行比较，较小的一方则将问题收缩，递归方程如下：

// 注意递归的边界条件和k为1的情况
func(nums1,n1, nums2,n2,k) {
    index1 = n1 + k/2 -1
    index2 = n2 + k/2 -1

    item1 = nums1[index1]
    item2 = nums2[index2]

    if item1 < item2 {
        //nums1进行收缩
        return func(num1, n1+k/2, nums2, n2, k- k/2)
    } else {
        return func(num1, n1, nums2, n2+k/2, k- k/2)
    }
} 

### 5 最长回文子串

考虑使用动态规划，dp(i,j)为bool值，表示i到j的子串是否是回文的。
初始化时，统计长度为1和2的回文情况。当j-i >1，即子串长度大于2时，
问题可以转化为 dp(i,j)转为为:
    dp(i,j) = s[i]==s[j] && dp(i+1, j-1)
遍历完成后，即可求最大回文子串

o(n)解法 : 马拉车算法求解  https://www.cnblogs.com/grandyang/p/4475985.html

### 11 盛水最多的容器

left, right双指针分别从头尾开始，因为短板效应，每次移动高度更小的那块板子去收缩

### 17 电话号码的组合
遍历字符串，保存已经遍历部分对笛卡尔积数组,pre保存已经遍历的组合情况 。 
dfs函数如下:
    func dfs(digits string, index int, pre []string) []string {}

### 19 链表的倒数第n个节点

快慢指针，两个指针间隔n, 每次移动一格，快指针 next为空时，表示定位到目标，进行删除即可


###  20 有效的括号
构造一个栈， 左括号入栈，右括号则配对出栈，如果无法配对，则直接非法。遍历完成后，如果栈不为空，则非法。

### 21 合并两个有序链表
难度为简单，直接逐个比较两个linklist的当前头，更小的入新链表即可。

### 22 n对括号对所有组合可能

依然可以考虑使用dfs，	res = dfs("", n, 0, 0, res)。

func dfs(pre string, n, left, right int, res []string) []string {

}
left, right 分别表示左右括号的已用个数，
当left > right 时，先一步可左可右。 left=right时，下一步只能选左。当left==n的时候，只能补右结束循环。
注意，在golang中， slice类型的形参的扩容无法如果想传递出去，必须将扩容后的slice返回

### 23  合并k个升序链表

用k个linklist 的head 构造一个最小堆，每次出堆后用当前节点的next入堆，构建新的堆。


这里使用golang container标准库的heap类型构建堆
https://pkg.go.dev/container@go1.15.6

https://www.cnblogs.com/huxianglin/p/6925119.html



### 31 下一个排列

	思路，从后向前，找到递减序列的结束点j，在递减序列中互相交换无法产生更大到值
	所以可以确定发生交换一定是0到j-1 和j到最后的两个区间各选一个节点。
	为了影响最小，就是拿前面的最低位j-1 和 后面区间中大于nums[j-1]的第一个数进行交换

	交换之后，再对后面区间进行调整，做成一个单调递增区间

### 32 最长有效括号

动态规划，dp[i]表示从i开始的最长有效括号，每次从头扫描到尾部。 
dp[i] =k的情况， 如果dp[i+k]也为合法括号，则更新dp[i]
如果dp[i-1] = (, dp[i+k] = ),则更新dp[i-1] = k + 2
每次扫描的下一个跨度根据dp[i]是否更新而定
如果一次从头到尾无dp更新，则表示已经全部结束，直接找到最大值返回
时间复杂度o(n*n)


另一种dp思路，应该会更简化： dp[i]表示以i结尾的字符串的最大有效括号长度
这样，如果s[i] = ),且s[i-1] = (, 则dp[i] = dp[i-2] + 2
如果s[i] = ), dp[i-1]=k >0, 且s[i-k-1] = (, 则dp[i] = dp[i-1] + 2 + dp[i-k-2] .
时间复杂度o(n)


### 33 搜索旋转排序数组

先判断是否发生过部分翻转，如果翻转，找到翻转位置，然后进行合理的二分搜索

### 34 排序数组中查找元素的第一个和最后一个位置

思路： 先二分查找找到等于target的一个点，然后双指针，左右移动，找到左右边界


### 39 组合总和 
从数组中选取数字之和等于target，元素可以多次使用。

思路： 对数组排序，从未选元素第一个取0到n次（n=target/arr[i])，然后递归子问题。

### 48 旋转图像

由外到里不断缩小正方形，对每圈正方形左如下操作：
step1: 依次进行四个角上元素swap
step2: 依次进行除角之外对边上元素swap
这里设上右下左四条边为a,b,c,d 思路就是依次swap(a,b), swap(a,c),swap(a,d)

### 49 字母异位词分组

先逐个将字符串放入一个代表a-z的数组桶中统计出现次数，并最终简化为一个新字符
如 hello 变为 e1h1ll2o1, 用一个hashmap来记录是否新字符对应的key是否出现
这里天然进行了一次字符的排序

### 53 最大子序和
求一个数组的连续子数组的最大和
解法一 : 时间复杂度o(n)
    if cur_sum + nums[i]  > nums[i] {
        cur_sum = cur_sum + nums[i]
    } else {
        cur_sum = nums[i]
    }

    if cur_sum > max {
        max = cur_sum
    }

follow up， 分治法的算法：
数组从中间一分为(0,center-1),center,(center+1,n)三部分， 最大值有三种情况，要么在左侧，要么在右侧，要么为以center为中心向左右延展的最大数

### 55  跳跃游戏

用一个reach 表示走到nums[i]时的最远跳跃距离。 
if reach < i 表示无法到达i， 否则表示可到达i, 此时从i最远跳远距离为 i + nums[i]，如果reach < i + nums[i] ，则更新reach为i + nums[i]

### 56 合并区间
先对数组按左边元素排序， 然后用cur_left 和 pre_right进行比较，判断是否需要合并，并确定合并后的right

### 62 不同路径
从网格左上到右下的所有可选路径数。 dp ,dp[i][j]表示到达nums[i][j]的可选方案数，
dp[i][j] = dp[i-1][j] + dp[i][j-1]  从第一行依次向后。 可以将二维化为一维， dp[i] = dp[i-1] + dp[i]


### 64 最小路径和 
dp ,思路类似62，可用dp[i][j]表示对应的最小和，也可简化为一维

### 70 爬楼梯

递归，斐波那契数列

### 72 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 
可插入，删除，替换

动态规划：
	//如果i,j对应的字符不同，则有三种方式，取三种方式的最小值
	dp_insert := dp(dpMem, word1, word2, i, j-1) + 1    //word1插入一个word2[j-1]
	dp_replace := dp(dpMem, word1, word2, i-1, j-1) + 1 //word1替换i字符为word2[j-1]
	dp_delete := dp(dpMem, word1, word2, i-1, j) + 1    // word1删除i,使用i-1与j进行比较


### 75 颜色分类

数组中包含0，1，2三种元素，相同数字进行合并排列 
要求：不使用代码库中的排序函数，同时原地一遍扫描解决

思路1: 两次遍历，第一次统计0，1，2的个数，然后进行二次遍历更新数组
思路2: 头尾指针，遍历数组，如果元素为0,则与left指针交换;如果为2,则与right指针交换。
思路2可以实现一次遍历，原地完成。

### 78 子集

输出数组全部子集
对每个元素要么取，要么不取，递归函数：func(nums []int, left int, pre []int) ，这里left表示下一个需要遍历对元素，pre表示已经遍历元素的选择情况
另外的思路： 数组长度n,所有选择用n位二进制表示，从0000 到1111 

### 79 矩阵中单词搜索

深度优先搜索， 依次取i,j开始的点进行 前后左右四个方向的子问题处理，如果有反向可以推进，则标记矩阵中对应节点为‘#’，如果无法继续，则还原节点内容



### 84  柱状图最大矩形面积
思路1 ：分治法，先求出包括mid的最大面积，与(left,mid-1), (mid+1, right)两子区间的最大面积做比较
因为最大面积要么在左右子区间，要么为包括mid的左右延伸区域
思路2 ：  暴力方法，求出每个元素高度对应的最大面积


### 85 最大矩形
思路，将矩阵逐行累加转化为柱形图，遇到0暂停本行累加。
然后求柱形图的最大矩形面积. 求柱形图的最大矩形面积使用leetcode 84的解法

### 94 二叉树中序遍历

递归代码很简洁，follw up要求使用非递归
